name: iOS Tests - Smoke Suite

# ============================================================
# SMOKE TEST SUITE - Quick Critical Path Validation
# ============================================================
# Tests: 39-71 tests across 11 modules (dynamic based on branch)
#
# S3 Drift Detection runs BRANCH-SPECIFIC tests:
#   dev/develop       â†’ dev only         (10 S3 tests) â†’ Total 27
#   qa                â†’ qa only          (10 S3 tests) â†’ Total 27
#   staging/stage     â†’ staging only     (10 S3 tests) â†’ Total 27
#   prod              â†’ prod + bces-iq   (18 S3 tests) â†’ Total 35
#   production/main   â†’ prod + bces-iq   (18 S3 tests) â†’ Total 35
#   bces-iq           â†’ bces-iq only     (10 S3 tests) â†’ Total 27
#   unknown/manual    â†’ ALL environments (42 S3 tests) â†’ Total 59
#
# Modules Covered:
#   Phase 1 (UI Checks):
#   - Module 0: S3 Drift Detection (branch-based: 10-42 tests, NO Appium)
#   - Module 1: Authentication UI  (4 tests)
#   - Module 2: Site Selection UI  (3 tests)
#   - Module 3: Asset UI           (2 tests)
#   - Module 4: Location UI        (2 tests)
#   - Module 5: Connections UI     (2 tests)
#   Phase 2 (CRUD Operations):
#   - Module 6: Login Flow         (1 test)
#   - Module 7: Asset CRUD         (4 tests)
#   - Module 8: Location CRUD      (4 tests)
#   - Module 9: Connection CRUD    (3 tests)
#   - Module 10: Issue CRUD        (4 tests)
#
# Individual module XMLs: src/test/resources/smoke/testng-smoke-*.xml
# Dashboard script:       .github/scripts/smoke-dashboard.sh
#
# API Capture (EXPERIMENTAL):
#   - Uses mitmproxy to capture HTTP/HTTPS traffic
#   - Proxy MUST be configured BEFORE simulator boots
#   - Certificate MUST be installed for HTTPS interception
#   - If app has certificate pinning, capture will fail
#   - eGalvanic app tested locally: NO cert pinning detected âœ…
# ============================================================
on:
  push:
    branches: [main, develop, dev, qa, staging, stage, prod, production, bces-iq]
  pull_request:
    branches: [main, develop, dev, qa, staging, stage, prod, production, bces-iq]
  workflow_dispatch:
    inputs:
      target_environment:
        description: 'S3 Drift environment (auto = detect from branch)'
        required: false
        default: 'auto'
        type: choice
        options:
          - 'auto'
          - 'all'
          - 'dev'
          - 'qa'
          - 'staging'
          - 'prod'
          - 'production'
          - 'bces-iq'
      run_full_suite_after:
        description: 'Run full test suite after smoke tests pass'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      capture_api:
        description: 'Capture API traffic (experimental)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

jobs:
  smoke-tests:
    runs-on: macos-15
    timeout-minutes: 420
    outputs:
      smoke_result: ${{ steps.smoke_status.outputs.result }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # ============================================================
      # Branch-Based S3 Environment Detection
      # Maps git branch â†’ S3 drift environment (dev/qa/staging/prod/bces-iq)
      # Manual override via workflow_dispatch target_environment input
      # ============================================================
      - name: Detect S3 Drift Environment
        id: s3_env
        run: |
          MANUAL_ENV="${{ github.event.inputs.target_environment }}"
          BRANCH_NAME="${{ github.head_ref || github.ref_name }}"
          
          echo "Branch: $BRANCH_NAME"
          echo "Manual override: ${MANUAL_ENV:-none}"
          
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # Branch â†’ S3 Environment Mapping
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # dev/develop       â†’ dev S3 only        (10 tests: 2 pre + 8 buckets)
          # qa                â†’ qa S3 only         (10 tests: 2 pre + 8 buckets)
          # staging/stage     â†’ staging S3 only    (10 tests: 2 pre + 8 buckets)
          # prod              â†’ prod S3 only       (10 tests: 2 pre + 8 buckets)
          # production/main   â†’ prod + bces-iq     (18 tests: 2 pre + 8 prod + 8 bces-iq)
          # bces-iq           â†’ bces-iq S3 only    (10 tests: 2 pre + 8 buckets)
          # unknown/other     â†’ ALL environments   (42 tests: all 5 envs)
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          
          # Priority: manual workflow_dispatch input > branch auto-detection
          if [ -n "$MANUAL_ENV" ] && [ "$MANUAL_ENV" != "auto" ]; then
            S3_ENV="$MANUAL_ENV"
            echo "Using manual override: $S3_ENV"
          else
            case "$BRANCH_NAME" in
              dev|develop)
                S3_ENV="dev" ;;
              qa)
                S3_ENV="qa" ;;
              staging|stage)
                S3_ENV="staging" ;;
              prod)
                S3_ENV="production" ;;
              production|main)
                S3_ENV="production" ;;
              bces-iq)
                S3_ENV="bces-iq" ;;
              *)
                S3_ENV="all"
                echo "âš ï¸ Unknown branch '$BRANCH_NAME' â€” running ALL S3 environments" ;;
            esac
            echo "Auto-detected from branch '$BRANCH_NAME': $S3_ENV"
          fi
          
          # Set XML path and test count based on environment
          case "$S3_ENV" in
            all)
              S3_XML="src/test/resources/smoke/testng-smoke-s3drift.xml"
              S3_TESTS=42
              S3_LABEL="ALL (5 environments)" ;;
            production)
              S3_XML="src/test/resources/smoke/testng-smoke-s3drift-production.xml"
              S3_TESTS=18
              S3_LABEL="PRODUCTION (prod + bces-iq)" ;;
            *)
              S3_XML="src/test/resources/smoke/testng-smoke-s3drift-${S3_ENV}.xml"
              S3_TESTS=10
              S3_LABEL="${S3_ENV^^} only" ;;
          esac
          
          # S3 (dynamic) + 17 mobile tests:
          # 1 Login + 1 Site + 4 Asset + 4 Location + 3 Connection + 4 Issue CRUD = 17
          TOTAL_TESTS=$((S3_TESTS + 17))
          
          echo "S3_ENV=$S3_ENV" >> $GITHUB_ENV
          echo "S3_XML=$S3_XML" >> $GITHUB_ENV
          echo "S3_TESTS=$S3_TESTS" >> $GITHUB_ENV
          echo "S3_LABEL=$S3_LABEL" >> $GITHUB_ENV
          echo "TOTAL_SMOKE_TESTS=$TOTAL_TESTS" >> $GITHUB_ENV
          
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  ğŸŒ¿ Branch:           $(printf '%-40s' "$BRANCH_NAME")â•‘"
          echo "â•‘  ğŸª£ S3 Environment:   $(printf '%-40s' "$S3_LABEL")â•‘"
          echo "â•‘  ğŸ§ª S3 Tests:         $(printf '%-40s' "$S3_TESTS")â•‘"
          echo "â•‘  ğŸ“„ S3 XML:           $(printf '%-40s' "$(basename $S3_XML)")â•‘"
          echo "â•‘  ğŸ“Š Total Smoke:      $(printf '%-40s' "$TOTAL_TESTS tests")â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Appium
        run: |
          npm install -g appium@next
          appium driver install xcuitest
          echo "âœ… Appium $(appium --version) installed"

      - name: Unzip App
        run: |
          unzip -o apps/Z-Platform-QA.zip -d apps/
          ls -la apps/

      # ============================================================
      # API CAPTURE PHASE 1: Install & Configure Proxy BEFORE Simulator
      # CRITICAL: Proxy must be running before simulator boots!
      # ============================================================
      - name: "[API Capture 1/5] Install mitmproxy"
        if: github.event.inputs.capture_api == 'true'
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘     ğŸ“¡ API CAPTURE - PHASE 1: Installing mitmproxy         â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          brew install mitmproxy
          
          echo "âœ… mitmproxy version: $(mitmproxy --version | head -1)"
          echo "âœ… mitmdump version: $(mitmdump --version | head -1)"

      - name: "[API Capture 2/5] Generate Certificates & Start Proxy"
        if: github.event.inputs.capture_api == 'true'
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘     ğŸ“¡ API CAPTURE - PHASE 2: Certificates & Proxy Start   â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          # Create directories
          mkdir -p ~/.mitmproxy
          mkdir -p reports/api_logs
          mkdir -p scripts
          
          # Generate certificates by running mitmdump briefly
          echo "Generating mitmproxy CA certificates..."
          (mitmdump --set confdir=~/.mitmproxy -p 19999 &)
          sleep 5
          pkill -f "mitmdump.*19999" 2>/dev/null || true
          sleep 2
          
          # Verify certificates exist
          if [ -f ~/.mitmproxy/mitmproxy-ca-cert.pem ]; then
            echo "âœ… CA Certificate generated:"
            ls -la ~/.mitmproxy/mitmproxy-ca-cert.pem
          else
            echo "âŒ Certificate generation failed!"
            exit 1
          fi
          
          # Start the actual proxy on port 8080
          echo "Starting mitmproxy on port 8080..."
          nohup mitmdump -p 8080 \
            -w reports/api_logs/traffic.flow \
            --set flow_detail=2 \
            --set stream_large_bodies=1 \
            > reports/api_logs/mitmdump.log 2>&1 &
          
          MITM_PID=$!
          echo "MITM_PID=$MITM_PID" >> $GITHUB_ENV
          echo "Proxy PID: $MITM_PID"
          
          sleep 5
          
          # Verify proxy is running
          if ps -p $MITM_PID > /dev/null 2>&1; then
            echo "âœ… mitmproxy running (PID: $MITM_PID)"
          else
            echo "âŒ mitmproxy failed to start!"
            cat reports/api_logs/mitmdump.log || true
            exit 1
          fi
          
          # Test proxy connectivity
          echo "Testing proxy connectivity..."
          HTTP_TEST=$(curl -x http://127.0.0.1:8080 -s -o /dev/null -w "%{http_code}" http://httpbin.org/get 2>/dev/null || echo "000")
          if [ "$HTTP_TEST" = "200" ]; then
            echo "âœ… Proxy HTTP test passed"
          else
            echo "âš ï¸ Proxy HTTP test returned: $HTTP_TEST"
          fi

      - name: "[API Capture 3/5] Configure System Proxy"
        if: github.event.inputs.capture_api == 'true'
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘     ğŸ“¡ API CAPTURE - PHASE 3: Configure System Proxy       â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          # List all network services
          echo "Available network services:"
          networksetup -listallnetworkservices
          
          # Configure proxy on ALL available interfaces
          # GitHub Actions macOS runners typically use "Ethernet"
          for SERVICE in "Ethernet" "Wi-Fi" "Thunderbolt Ethernet" "USB 10/100/1000 LAN" "Thunderbolt Bridge"; do
            echo "Attempting to configure: $SERVICE"
            
            # HTTP Proxy
            networksetup -setwebproxy "$SERVICE" 127.0.0.1 8080 off 2>/dev/null && \
              networksetup -setwebproxystate "$SERVICE" on 2>/dev/null && \
              echo "  âœ… HTTP proxy set on $SERVICE" || \
              echo "  â­ï¸ $SERVICE not available"
            
            # HTTPS Proxy
            networksetup -setsecurewebproxy "$SERVICE" 127.0.0.1 8080 off 2>/dev/null && \
              networksetup -setsecurewebproxystate "$SERVICE" on 2>/dev/null && \
              echo "  âœ… HTTPS proxy set on $SERVICE" || true
          done
          
          echo ""
          echo "=== Proxy Configuration Summary ==="
          for SERVICE in "Ethernet" "Wi-Fi"; do
            echo "$SERVICE HTTP:"
            networksetup -getwebproxy "$SERVICE" 2>/dev/null | grep -E "Enabled|Port" || echo "  Not configured"
            echo "$SERVICE HTTPS:"
            networksetup -getsecurewebproxy "$SERVICE" 2>/dev/null | grep -E "Enabled|Port" || echo "  Not configured"
          done

      # ============================================================
      # NOW Boot Simulator (after proxy is configured)
      # ============================================================
      - name: Find and Select Simulator
        id: find_simulator
        run: |
          echo "=== Available Simulators ==="
          xcrun simctl list devices available
          
          # Try to find iPhone 16 Pro first, then fallback
          UDID=$(xcrun simctl list devices available | grep -A 100 "iOS 18" | grep "iPhone 16 Pro" | head -1 | awk -F '[()]' '{print $2}')
          [ -z "$UDID" ] && UDID=$(xcrun simctl list devices available | grep -E "iPhone 16 Pro" | head -1 | awk -F '[()]' '{print $2}')
          [ -z "$UDID" ] && UDID=$(xcrun simctl list devices available | grep -E "iPhone 1[5-6]" | head -1 | awk -F '[()]' '{print $2}')
          
          if [ -z "$UDID" ]; then
            echo "âŒ No iPhone simulator found!"
            exit 1
          fi
          
          DEVICE_NAME=$(xcrun simctl list devices available | grep "$UDID" | sed 's/(.*//' | xargs)
          PLATFORM_VERSION=$(xcrun simctl list devices available | grep -B 20 "$UDID" | grep "iOS" | tail -1 | sed 's/-- iOS //' | sed 's/ --.*//')
          
          echo "ğŸ“± Selected Device: $DEVICE_NAME"
          echo "ğŸ“± UDID: $UDID"
          echo "ğŸ“± iOS Version: $PLATFORM_VERSION"
          
          echo "DEVICE_NAME=$DEVICE_NAME" >> $GITHUB_ENV
          echo "SIMULATOR_UDID=$UDID" >> $GITHUB_ENV
          echo "PLATFORM_VERSION=$PLATFORM_VERSION" >> $GITHUB_ENV

      - name: Boot Simulator
        run: |
          echo "=== Booting Simulator ==="
          echo "UDID: ${{ env.SIMULATOR_UDID }}"
          
          xcrun simctl boot "${{ env.SIMULATOR_UDID }}" 2>/dev/null || true
          
          echo "=== Waiting for Simulator to be fully booted ==="
          for i in {1..60}; do
            STATE=$(xcrun simctl list devices | grep "${{ env.SIMULATOR_UDID }}" | grep -o "(Booted)" || true)
            if [ "$STATE" = "(Booted)" ]; then
              echo "âœ… Simulator booted after $i seconds"
              break
            fi
            echo "   Waiting... ($i/60)"
            sleep 1
          done
          
          echo "=== Post-boot stabilization (45s) ==="
          sleep 45
          echo "âœ… Simulator ready"

      # ============================================================
      # API CAPTURE PHASE 4: Install Certificate in Simulator
      # ============================================================
      - name: "[API Capture 4/5] Install Certificate in Simulator"
        if: github.event.inputs.capture_api == 'true'
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘     ğŸ“¡ API CAPTURE - PHASE 4: Install Cert in Simulator    â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          CERT_PATH=~/.mitmproxy/mitmproxy-ca-cert.pem
          
          if [ -f "$CERT_PATH" ]; then
            echo "Installing mitmproxy CA certificate in simulator..."
            xcrun simctl keychain "${{ env.SIMULATOR_UDID }}" add-root-cert "$CERT_PATH" 2>&1 || true
            echo "âœ… Certificate installation attempted"
            
            # Give time for certificate to be processed
            sleep 5
            
            # Test HTTPS through proxy from Mac (to verify proxy works)
            echo "Testing HTTPS proxy (from Mac)..."
            HTTPS_TEST=$(curl -x http://127.0.0.1:8080 -k -s -o /dev/null -w "%{http_code}" https://httpbin.org/get 2>/dev/null || echo "000")
            echo "HTTPS test result: $HTTPS_TEST"
          else
            echo "âŒ Certificate not found at: $CERT_PATH"
          fi

      # ============================================================
      # Pre-build WDA and Start Appium
      # ============================================================
      - name: Pre-build WebDriverAgent
        run: |
          echo "Pre-building WebDriverAgent to avoid timeout on first test..."
          WDA_PATH=$(find ~/.appium -name "WebDriverAgent.xcodeproj" -type f 2>/dev/null | head -1 | xargs dirname)
          
          if [ -n "$WDA_PATH" ]; then
            echo "Found WDA at: $WDA_PATH"
            cd "$WDA_PATH"
            
            xcodebuild build-for-testing \
              -project WebDriverAgent.xcodeproj \
              -scheme WebDriverAgentRunner \
              -destination "platform=iOS Simulator,id=${{ env.SIMULATOR_UDID }}" \
              -derivedDataPath /tmp/wda-build \
              -quiet || echo "WDA pre-build completed (may have warnings)"
            
            echo "âœ… WDA pre-built"
          else
            echo "âš ï¸ WDA not found, will be built on first test run"
          fi

      - name: Start Appium Server
        run: |
          echo "Starting Appium..."
          appium --relaxed-security --log-level error > appium.log 2>&1 &
          APPIUM_PID=$!
          echo "Appium PID: $APPIUM_PID"
          
          APPIUM_READY=false
          for i in {1..60}; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:4723/status 2>/dev/null || echo "000")
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "âœ… Appium server is ready! (HTTP $HTTP_STATUS)"
              APPIUM_READY=true
              break
            fi
            echo "Waiting for Appium... ($i/60) - HTTP: $HTTP_STATUS"
            sleep 2
          done
          
          if [ "$APPIUM_READY" = false ]; then
            echo "âŒ Appium failed to start"
            cat appium.log | tail -30
            exit 1
          fi
          
          echo "Waiting 10s for Appium to fully initialize..."
          sleep 10
          echo "âœ… Appium server verified and ready"

      - name: Warm-up WDA Session
        env:
          SIMULATOR_UDID: ${{ env.SIMULATOR_UDID }}
          APP_PATH: ${{ github.workspace }}/apps/Z Platform-QA.app
        run: |
          echo "=== Warming up WDA with a test session ==="
          
          for attempt in 1 2 3; do
            echo "Warm-up attempt $attempt/3..."
            
            SESSION_RESPONSE=$(curl -s -X POST http://127.0.0.1:4723/session \
              -H "Content-Type: application/json" \
              -d '{
                "capabilities": {
                  "alwaysMatch": {
                    "platformName": "iOS",
                    "appium:automationName": "XCUITest",
                    "appium:deviceName": "'"${{ env.DEVICE_NAME }}"'",
                    "appium:udid": "'"$SIMULATOR_UDID"'",
                    "appium:platformVersion": "'"${{ env.PLATFORM_VERSION }}"'",
                    "appium:app": "'"$APP_PATH"'",
                    "appium:wdaLaunchTimeout": 600000,
                    "appium:wdaConnectionTimeout": 300000,
                    "appium:useNewWDA": false,
                    "appium:noReset": false
                  }
                }
              }' --max-time 600 2>&1) || true
            
            SESSION_ID=$(echo "$SESSION_RESPONSE" | grep -o '"sessionId":"[^"]*"' | cut -d'"' -f4 || true)
            
            if [ -n "$SESSION_ID" ]; then
              echo "âœ… WDA warm-up session created: $SESSION_ID"
              sleep 10
              curl -s -X DELETE "http://127.0.0.1:4723/session/$SESSION_ID" || true
              echo "âœ… Warm-up session closed"
              sleep 5
              echo "âœ… WDA warm-up complete"
              break
            else
              echo "âš ï¸ Attempt $attempt failed"
              [ $attempt -lt 3 ] && sleep 30
            fi
          done

      # ============================================================
      # AWS Credentials for S3 Drift Detection (Module 0)
      # ============================================================
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-2

      - name: Verify AWS Access
        run: |
          echo "Verifying AWS CLI access for S3 drift detection..."
          aws sts get-caller-identity || { echo "âŒ AWS credentials not configured. Add secrets: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY"; exit 1; }
          echo "âœ… AWS access verified"

      # ============================================================
      # Run Tests â€” Module-by-Module with Dashboard
      # ============================================================
      - name: Run Smoke Tests with Dashboard
        id: smoke_tests
        continue-on-error: true
        env:
          SIMULATOR_UDID: ${{ env.SIMULATOR_UDID }}
          PLATFORM_VERSION: ${{ env.PLATFORM_VERSION }}
          DEVICE_NAME: ${{ env.DEVICE_NAME }}
          APP_PATH: ${{ github.workspace }}/apps/Z Platform-QA.app
          S3_ENV: ${{ env.S3_ENV }}
          S3_XML: ${{ env.S3_XML }}
          S3_TESTS: ${{ env.S3_TESTS }}
          S3_LABEL: ${{ env.S3_LABEL }}
          TOTAL_SMOKE_TESTS: ${{ env.TOTAL_SMOKE_TESTS }}
        run: |
          bash .github/scripts/smoke-dashboard.sh

      # ============================================================
      # API CAPTURE PHASE 5: Generate Report
      # ============================================================
      - name: "[API Capture 5/5] Generate API Traffic Report"
        if: always() && github.event.inputs.capture_api == 'true'
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘     ğŸ“¡ API CAPTURE - PHASE 5: Generate Report              â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          # Stop mitmproxy gracefully
          if [ -n "${{ env.MITM_PID }}" ]; then
            echo "Stopping mitmproxy (PID: ${{ env.MITM_PID }})..."
            kill ${{ env.MITM_PID }} 2>/dev/null || true
            sleep 3
          fi
          
          # Also kill any remaining mitmdump processes
          pkill -f "mitmdump" 2>/dev/null || true
          
          # Disable system proxy
          echo "Disabling system proxy..."
          for SERVICE in "Ethernet" "Wi-Fi"; do
            networksetup -setwebproxystate "$SERVICE" off 2>/dev/null || true
            networksetup -setsecurewebproxystate "$SERVICE" off 2>/dev/null || true
          done
          
          # Check captured traffic
          echo ""
          echo "=== Captured Traffic Analysis ==="
          
          FLOW_FILE="reports/api_logs/traffic.flow"
          
          if [ -f "$FLOW_FILE" ]; then
            FLOW_SIZE=$(ls -lh "$FLOW_FILE" | awk '{print $5}')
            FLOW_BYTES=$(ls -l "$FLOW_FILE" | awk '{print $5}')
            echo "Traffic file: $FLOW_FILE"
            echo "File size: $FLOW_SIZE ($FLOW_BYTES bytes)"
            
            if [ "$FLOW_BYTES" -gt 0 ]; then
              echo "âœ… Traffic was captured!"
              
              # Install mitmproxy Python library for parsing
              pip3 install mitmproxy --quiet 2>/dev/null || true
              
              # Create parser script (sed strips leading 10 spaces for YAML compatibility)
              sed 's/^          //' > scripts/parse_api.py << 'PYSCRIPT'
          import json
          import sys
          import os
          from datetime import datetime

          def main(flow_file):
              if not os.path.exists(flow_file):
                  print(f"âš ï¸ Flow file not found: {flow_file}")
                  return

              file_size = os.path.getsize(flow_file)
              print(f"Flow file size: {file_size} bytes")

              if file_size == 0:
                  print("âš ï¸ No API traffic captured (0 bytes)")
                  print("   Possible reasons:")
                  print("   1. iOS Simulator did not use system proxy")
                  print("   2. App has certificate pinning enabled")
                  print("   3. Proxy was not running during tests")
                  return

              try:
                  from mitmproxy import io as mitmio

                  flows_data = []
                  failed_apis = []
                  egalvanic_apis = []
                  total = 0

                  with open(flow_file, "rb") as f:
                      for flow in mitmio.FlowReader(f).stream():
                          if hasattr(flow, 'request'):
                              total += 1
                              url = flow.request.pretty_url
                              method = flow.request.method

                              flow_info = {
                                  "method": method,
                                  "url": url,
                                  "host": flow.request.host,
                                  "status": None,
                                  "error": None
                              }

                              # Check for eGalvanic APIs
                              if 'egalvanic' in url.lower():
                                  egalvanic_apis.append(flow_info)

                              if hasattr(flow, 'response') and flow.response:
                                  flow_info["status"] = flow.response.status_code
                                  if flow.response.status_code >= 400:
                                      flow_info["response_preview"] = (flow.response.get_text() or "")[:500]
                                      failed_apis.append(flow_info)
                              elif hasattr(flow, 'error') and flow.error:
                                  flow_info["error"] = str(flow.error)
                                  failed_apis.append(flow_info)

                              flows_data.append(flow_info)

                  # Print summary
                  print(f"\n{'='*70}")
                  print(f"ğŸ“¡ API TRAFFIC REPORT")
                  print(f"{'='*70}")
                  print(f"Total requests captured: {total}")
                  print(f"Failed requests (4xx/5xx): {len(failed_apis)}")
                  print(f"eGalvanic API calls: {len(egalvanic_apis)}")

                  # Group by host
                  hosts = {}
                  for f in flows_data:
                      host = f.get('host', 'unknown')
                      hosts[host] = hosts.get(host, 0) + 1

                  print(f"\nğŸ“Š Traffic by Host:")
                  for host, count in sorted(hosts.items(), key=lambda x: -x[1])[:20]:
                      marker = "ğŸ¯" if 'egalvanic' in host.lower() else "  "
                      print(f"  {marker} {host}: {count} requests")

                  if egalvanic_apis:
                      print(f"\nğŸ¯ eGalvanic API Calls ({len(egalvanic_apis)}):")
                      for api in egalvanic_apis[:10]:  # Show first 10
                          status = api.get('status', 'N/A')
                          print(f"  [{status}] {api['method']} {api['url'][:80]}")

                  if failed_apis:
                      print(f"\nâŒ Failed API Calls ({len(failed_apis)}):")
                      for api in failed_apis[:10]:  # Show first 10
                          status = api.get('status') or api.get('error', 'unknown')
                          print(f"  [{status}] {api['method']} {api['url'][:80]}")

                  # Save detailed report
                  os.makedirs("reports/api_logs", exist_ok=True)
                  report = {
                      "timestamp": datetime.now().isoformat(),
                      "total_requests": total,
                      "failed_count": len(failed_apis),
                      "egalvanic_count": len(egalvanic_apis),
                      "hosts": hosts,
                      "failed_apis": failed_apis[:50],
                      "egalvanic_apis": egalvanic_apis[:50]
                  }

                  with open("reports/api_logs/api_report.json", "w") as f:
                      json.dump(report, f, indent=2)
                  print(f"\nâœ… Detailed report saved to: reports/api_logs/api_report.json")

              except ImportError:
                  print("âš ï¸ mitmproxy library not available for parsing")
                  print("   Raw flow file is still available in artifacts")
              except Exception as e:
                  print(f"Error parsing flow file: {e}")

          if __name__ == "__main__":
              main(sys.argv[1] if len(sys.argv) > 1 else "reports/api_logs/traffic.flow")
          PYSCRIPT
              
              # Run parser
              python3 scripts/parse_api.py "$FLOW_FILE" || echo "Parser failed, raw file still available"
              
            else
              echo ""
              echo "âš ï¸ NO TRAFFIC CAPTURED (0 bytes)"
              echo ""
              echo "Possible reasons:"
              echo "1. iOS Simulator does not use macOS system proxy"
              echo "2. App has certificate pinning that blocks interception"
              echo "3. Network configuration issue"
              echo ""
              echo "Mitmdump log:"
              cat reports/api_logs/mitmdump.log 2>/dev/null | tail -30 || echo "No log available"
            fi
          else
            echo "âŒ Traffic flow file not found: $FLOW_FILE"
            ls -la reports/api_logs/ 2>/dev/null || echo "Directory not found"
          fi

      # ============================================================
      # Cleanup and Results
      # ============================================================
      - name: Capture Smoke Test Status
        id: smoke_status
        if: always()
        run: |
          # Dashboard script sets SMOKE_RESULT env var
          if [ "${{ env.SMOKE_RESULT }}" = "passed" ] || [ "${{ steps.smoke_tests.outcome }}" = "success" ]; then
            echo "result=passed" >> $GITHUB_OUTPUT
          else
            echo "result=failed" >> $GITHUB_OUTPUT
          fi

      - name: Upload Test Reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-test-reports
          path: |
            target/surefire-reports/
            reports/
            screenshots/
          retention-days: 7
          if-no-files-found: warn

      - name: Upload API Capture Artifacts
        if: always() && github.event.inputs.capture_api == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: api-capture-logs
          path: |
            reports/api_logs/
          retention-days: 7

      - name: Smoke Test Summary
        if: always()
        run: |
          echo ""
          echo "  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "  â”‚  ğŸ“Š  SMOKE TEST FINAL SUMMARY"
          echo "  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "  â”‚"
          echo "  â”‚  Result:   ${{ env.SMOKE_RESULT || steps.smoke_status.outputs.result }}"
          echo "  â”‚  Passed:   ${{ env.SMOKE_PASSED || '?' }}/${{ env.TOTAL_SMOKE_TESTS || '?' }}"
          echo "  â”‚  Failed:   ${{ env.SMOKE_FAILED || '?' }}"
          echo "  â”‚  Skipped:  ${{ env.SMOKE_SKIPPED || '?' }}"
          echo "  â”‚  Duration: ${{ env.SMOKE_DURATION || '?' }}s"
          echo "  â”‚"
          echo "  â”‚  ğŸ“‹ Modules:"
          echo "  â”‚     0. S3 Drift [${{ env.S3_LABEL }}]  (${{ env.S3_TESTS }} tests, no Appium)"
          echo "  â”‚     1. Login               (1 test)"
          echo "  â”‚     2. Site Selection      (1 test)"
          echo "  â”‚     3. Asset CRUD          (4 tests)"
          echo "  â”‚     4. Location CRUD       (4 tests)"
          echo "  â”‚     5. Connection CRUD     (3 tests)"
          echo "  â”‚"

          if [ "${{ github.event.inputs.capture_api }}" = "true" ]; then
            echo "  â”‚  ğŸ“¡ API Capture: ENABLED"
            if [ -f "reports/api_logs/api_report.json" ]; then
              echo "  â”‚     Report generated â€” check artifacts"
            else
              echo "  â”‚     âš ï¸ No traffic captured â€” see logs"
            fi
            echo "  â”‚"
          fi

          echo "  â”‚  ğŸ”— ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo "  â”‚"
          echo "  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo ""

  # ========================================
  # TRIGGER FULL SUITE (Optional)
  # ========================================
  trigger-full-suite:
    needs: smoke-tests
    if: |
      always() && 
      needs.smoke-tests.outputs.smoke_result == 'passed' && 
      github.event.inputs.run_full_suite_after == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
      - name: Trigger Full Test Suite
        uses: actions/github-script@v7
        with:
          script: |
            console.log('ğŸš€ Smoke tests passed! Triggering full test suite...');
            
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ios-tests-parallel.yml',
              ref: context.ref,
              inputs: {
                job_selection: 'all'
              }
            });
            
            console.log('âœ… Full test suite triggered successfully');

      - name: Summary
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘    ğŸš€ FULL TEST SUITE TRIGGERED                            â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
