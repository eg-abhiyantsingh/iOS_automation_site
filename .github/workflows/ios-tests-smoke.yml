name: iOS Tests - Smoke Suite

# ============================================================
# SMOKE TEST SUITE - Quick Critical Path Validation
# ============================================================
# Purpose: Fast validation of core functionality before full suite
# Tests: 17 tests across 5 modules (~15-20 min execution)
# 
# Features:
#   - API Traffic Capture using mitmproxy
#   - Failed API Detection (4xx, 5xx responses)
#   - API Report Generation
#
# Modules Covered:
#   - Authentication: 4 tests (Welcome, Company Code, Login)
#   - Site Selection: 4 tests (UI, Site List, Search, Dashboard)
#   - Asset Management: 3 tests (New Asset, Fields, Class)
#   - Location: 3 tests (Building UI, Save, Name)
#   - Connections: 3 tests (Tab, Header, List)
# ============================================================

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      run_full_suite_after:
        description: 'Run full test suite after smoke tests pass'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      capture_api:
        description: 'Capture API traffic for debugging'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

jobs:
  smoke-tests:
    runs-on: macos-15
    timeout-minutes: 420
    outputs:
      smoke_result: ${{ steps.smoke_status.outputs.result }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Appium
        run: |
          npm install -g appium@next
          appium driver install xcuitest
          echo "âœ… Appium $(appium --version) installed"

      # ============================================================
      # API CAPTURE SETUP
      # ============================================================
      - name: Setup API Capture
        if: github.event.inputs.capture_api != 'false'
        run: |
          echo "ğŸ“¡ Setting up API traffic capture..."
          
          # Install mitmproxy
          brew install mitmproxy
          echo "âœ… mitmproxy installed: $(mitmproxy --version)"
          
          # Create directories
          mkdir -p reports/api_logs scripts
          
          # Create Python script for parsing API traffic
          cat > scripts/parse_api_traffic.py << 'PYSCRIPT'
          #!/usr/bin/env python3
          """
          API Traffic Parser for iOS Automation
          Parses mitmproxy flow files and generates reports
          """
          import json
          import sys
          import os
          from datetime import datetime

          def parse_flow_file(flow_file):
              """Parse mitmproxy flow file and extract API calls"""
              failed_apis = []
              all_apis = []
              
              try:
                  from mitmproxy import io as mitmio
                  
                  with open(flow_file, "rb") as f:
                      reader = mitmio.FlowReader(f)
                      for flow in reader.stream():
                          if hasattr(flow, 'response') and flow.response:
                              # Extract API details
                              api_call = {
                                  "timestamp": datetime.now().isoformat(),
                                  "method": flow.request.method,
                                  "url": flow.request.pretty_url,
                                  "status": flow.response.status_code,
                                  "reason": getattr(flow.response, 'reason', ''),
                                  "request_headers": dict(flow.request.headers) if flow.request.headers else {},
                                  "response_headers": dict(flow.response.headers) if flow.response.headers else {},
                                  "request_body": "",
                                  "response_body": ""
                              }
                              
                              # Safely get request body
                              try:
                                  req_text = flow.request.get_text()
                                  if req_text:
                                      api_call["request_body"] = req_text[:1000]
                              except:
                                  pass
                              
                              # Safely get response body
                              try:
                                  resp_text = flow.response.get_text()
                                  if resp_text:
                                      api_call["response_body"] = resp_text[:2000]
                              except:
                                  pass
                              
                              all_apis.append(api_call)
                              
                              # Check for failed APIs (4xx, 5xx)
                              if flow.response.status_code >= 400:
                                  failed_apis.append(api_call)
                                  
              except ImportError:
                  print("âš ï¸ mitmproxy not installed, skipping flow parsing")
                  return [], []
              except Exception as e:
                  print(f"âš ï¸ Error parsing flow file: {e}")
                  return [], []
              
              return all_apis, failed_apis

          def generate_report(all_apis, failed_apis, output_dir="reports/api_logs"):
              """Generate API traffic reports"""
              os.makedirs(output_dir, exist_ok=True)
              
              # Console Report
              print("\n" + "=" * 70)
              print("                    ğŸ“¡ API TRAFFIC REPORT")
              print("=" * 70)
              print(f"\nğŸ“Š Summary: {len(all_apis)} total API calls, {len(failed_apis)} failed\n")
              
              if failed_apis:
                  print("âŒ FAILED API CALLS:")
                  print("-" * 70)
                  for api in failed_apis:
                      print(f"\nğŸ”´ [{api['status']}] {api['method']} {api['url']}")
                      if api.get('reason'):
                          print(f"   Reason: {api['reason']}")
                      if api.get('response_body'):
                          body = api['response_body'][:300]
                          print(f"   Response: {body}{'...' if len(api['response_body']) > 300 else ''}")
                  print("\n" + "-" * 70)
              else:
                  print("âœ… No failed API calls detected!\n")
              
              # JSON Report
              json_report = {
                  "generated_at": datetime.now().isoformat(),
                  "summary": {
                      "total_calls": len(all_apis),
                      "failed_calls": len(failed_apis),
                      "success_rate": f"{((len(all_apis) - len(failed_apis)) / len(all_apis) * 100):.1f}%" if all_apis else "N/A"
                  },
                  "failed_apis": failed_apis,
                  "all_apis": all_apis
              }
              
              with open(f"{output_dir}/api_report.json", "w") as f:
                  json.dump(json_report, f, indent=2)
              print(f"ğŸ“ JSON report saved: {output_dir}/api_report.json")
              
              # HTML Report
              html_report = generate_html_report(all_apis, failed_apis)
              with open(f"{output_dir}/api_report.html", "w") as f:
                  f.write(html_report)
              print(f"ğŸ“ HTML report saved: {output_dir}/api_report.html")
              
              # Failed APIs only (for quick reference)
              if failed_apis:
                  with open(f"{output_dir}/failed_apis.json", "w") as f:
                      json.dump(failed_apis, f, indent=2)
                  print(f"ğŸ“ Failed APIs saved: {output_dir}/failed_apis.json")
              
              return len(failed_apis)

          def generate_html_report(all_apis, failed_apis):
              """Generate HTML report for API traffic"""
              html = """<!DOCTYPE html>
          <html>
          <head>
              <title>API Traffic Report</title>
              <style>
                  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 20px; background: #f5f5f5; }
                  .container { max-width: 1200px; margin: 0 auto; }
                  .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 10px; margin-bottom: 20px; }
                  .summary { display: flex; gap: 20px; margin-bottom: 20px; }
                  .card { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); flex: 1; }
                  .card h3 { margin-top: 0; color: #333; }
                  .success { color: #28a745; }
                  .failure { color: #dc3545; }
                  .api-list { background: white; border-radius: 10px; overflow: hidden; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
                  .api-item { padding: 15px 20px; border-bottom: 1px solid #eee; }
                  .api-item:last-child { border-bottom: none; }
                  .api-item.failed { background: #fff5f5; border-left: 4px solid #dc3545; }
                  .api-item.success { border-left: 4px solid #28a745; }
                  .status { display: inline-block; padding: 2px 8px; border-radius: 4px; font-weight: bold; margin-right: 10px; }
                  .status.s2xx { background: #d4edda; color: #155724; }
                  .status.s4xx { background: #f8d7da; color: #721c24; }
                  .status.s5xx { background: #721c24; color: white; }
                  .method { font-weight: bold; color: #667eea; }
                  .url { word-break: break-all; color: #666; }
                  .response-body { background: #f8f9fa; padding: 10px; border-radius: 5px; margin-top: 10px; font-family: monospace; font-size: 12px; white-space: pre-wrap; max-height: 200px; overflow-y: auto; }
                  .section-title { margin: 30px 0 15px; color: #333; }
              </style>
          </head>
          <body>
              <div class="container">
                  <div class="header">
                      <h1>ğŸ“¡ API Traffic Report</h1>
                      <p>Generated: """ + datetime.now().strftime("%Y-%m-%d %H:%M:%S") + """</p>
                  </div>
                  
                  <div class="summary">
                      <div class="card">
                          <h3>Total API Calls</h3>
                          <div style="font-size: 48px; font-weight: bold;">""" + str(len(all_apis)) + """</div>
                      </div>
                      <div class="card">
                          <h3>Failed Calls</h3>
                          <div style="font-size: 48px; font-weight: bold;" class="failure">""" + str(len(failed_apis)) + """</div>
                      </div>
                      <div class="card">
                          <h3>Success Rate</h3>
                          <div style="font-size: 48px; font-weight: bold;" class="success">""" + (f"{((len(all_apis) - len(failed_apis)) / len(all_apis) * 100):.1f}%" if all_apis else "N/A") + """</div>
                      </div>
                  </div>
          """
              
              # Failed APIs section
              if failed_apis:
                  html += """
                  <h2 class="section-title">âŒ Failed API Calls</h2>
                  <div class="api-list">
          """
                  for api in failed_apis:
                      status_class = "s4xx" if api['status'] < 500 else "s5xx"
                      html += f"""
                      <div class="api-item failed">
                          <span class="status {status_class}">{api['status']}</span>
                          <span class="method">{api['method']}</span>
                          <span class="url">{api['url']}</span>
                          {f'<div class="response-body">{api["response_body"][:500]}</div>' if api.get('response_body') else ''}
                      </div>
          """
                  html += "</div>"
              
              # All APIs section
              html += """
                  <h2 class="section-title">ğŸ“‹ All API Calls</h2>
                  <div class="api-list">
          """
              for api in all_apis[-50:]:  # Show last 50
                  status_class = "s2xx" if api['status'] < 400 else ("s4xx" if api['status'] < 500 else "s5xx")
                  item_class = "failed" if api['status'] >= 400 else "success"
                  html += f"""
                      <div class="api-item {item_class}">
                          <span class="status {status_class}">{api['status']}</span>
                          <span class="method">{api['method']}</span>
                          <span class="url">{api['url']}</span>
                      </div>
          """
              html += """
                  </div>
              </div>
          </body>
          </html>
          """
              return html

          if __name__ == "__main__":
              flow_file = sys.argv[1] if len(sys.argv) > 1 else "api_traffic.flow"
              
              if not os.path.exists(flow_file):
                  print(f"âš ï¸ Flow file not found: {flow_file}")
                  sys.exit(0)
              
              all_apis, failed_apis = parse_flow_file(flow_file)
              failed_count = generate_report(all_apis, failed_apis)
              
              print(f"\n{'âŒ' if failed_count else 'âœ…'} {failed_count} API failures detected")
              sys.exit(0)  # Don't fail the build based on API failures
          PYSCRIPT
          
          chmod +x scripts/parse_api_traffic.py
          echo "âœ… API capture setup complete"

      - name: Unzip App
        run: |
          unzip -o apps/Z-Platform-QA.zip -d apps/
          ls -la apps/

      - name: Boot Simulator and Wait Until Ready
        run: |
          echo "=== Available Simulators ==="
          xcrun simctl list devices available
          
          UDID=$(xcrun simctl list devices available | grep -A 100 "iOS 18" | grep "iPhone 16 Pro" | head -1 | awk -F '[()]' '{print $2}')
          [ -z "$UDID" ] && UDID=$(xcrun simctl list devices available | grep -E "iPhone 16 Pro" | head -1 | awk -F '[()]' '{print $2}')
          [ -z "$UDID" ] && UDID=$(xcrun simctl list devices available | grep -E "iPhone 1[5-6]" | head -1 | awk -F '[()]' '{print $2}')
          
          if [ -z "$UDID" ]; then
            echo "âŒ No iPhone simulator found!"
            exit 1
          fi
          
          DEVICE_NAME=$(xcrun simctl list devices available | grep "$UDID" | sed 's/(.*//' | xargs)
          PLATFORM_VERSION=$(xcrun simctl list devices available | grep -B 20 "$UDID" | grep "iOS" | tail -1 | sed 's/-- iOS //' | sed 's/ --.*//')
          
          echo "ğŸ“± Selected Device: $DEVICE_NAME"
          echo "ğŸ“± UDID: $UDID"
          echo "ğŸ“± iOS Version: $PLATFORM_VERSION"
          
          echo "DEVICE_NAME=$DEVICE_NAME" >> $GITHUB_ENV
          echo "SIMULATOR_UDID=$UDID" >> $GITHUB_ENV
          echo "PLATFORM_VERSION=$PLATFORM_VERSION" >> $GITHUB_ENV
          
          echo "=== Booting Simulator ==="
          xcrun simctl boot "$UDID" 2>/dev/null || true
          
          echo "=== Waiting for Simulator to be fully booted ==="
          for i in {1..60}; do
            STATE=$(xcrun simctl list devices | grep "$UDID" | grep -o "(Booted)" || true)
            if [ "$STATE" = "(Booted)" ]; then
              echo "âœ… Simulator booted after $i seconds"
              break
            fi
            echo "   Waiting... ($i/60)"
            sleep 1
          done
          
          echo "=== Post-boot stabilization (45s) ==="
          sleep 45
          echo "âœ… Simulator ready"

      - name: Pre-build WebDriverAgent
        run: |
          echo "Pre-building WebDriverAgent to avoid timeout on first test..."
          WDA_PATH=$(find ~/.appium -name "WebDriverAgent.xcodeproj" -type f 2>/dev/null | head -1 | xargs dirname)
          
          if [ -n "$WDA_PATH" ]; then
            echo "Found WDA at: $WDA_PATH"
            cd "$WDA_PATH"
            
            xcodebuild build-for-testing \
              -project WebDriverAgent.xcodeproj \
              -scheme WebDriverAgentRunner \
              -destination "platform=iOS Simulator,id=${{ env.SIMULATOR_UDID }}" \
              -derivedDataPath /tmp/wda-build \
              -quiet || echo "WDA pre-build completed (may have warnings)"
            
            echo "âœ… WDA pre-built"
          else
            echo "âš ï¸ WDA not found, will be built on first test run"
          fi

      - name: Start Appium Server
        run: |
          echo "Starting Appium..."
          appium --relaxed-security --log-level info > appium.log 2>&1 &
          APPIUM_PID=$!
          echo "Appium PID: $APPIUM_PID"
          
          APPIUM_READY=false
          for i in {1..60}; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:4723/status 2>/dev/null || echo "000")
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "âœ… Appium server is ready! (HTTP $HTTP_STATUS)"
              APPIUM_READY=true
              break
            fi
            echo "Waiting for Appium... ($i/60) - HTTP: $HTTP_STATUS"
            sleep 2
          done
          
          if [ "$APPIUM_READY" = false ]; then
            echo "âŒ Appium failed to start"
            cat appium.log | tail -30
            exit 1
          fi
          
          echo "Waiting 10s for Appium to fully initialize..."
          sleep 10
          echo "âœ… Appium server verified and ready"

      - name: Warm-up WDA Session
        env:
          SIMULATOR_UDID: ${{ env.SIMULATOR_UDID }}
          APP_PATH: ${{ github.workspace }}/apps/Z Platform-QA.app
        run: |
          echo "=== Warming up WDA with a test session ==="
          
          for attempt in 1 2 3; do
            echo "Warm-up attempt $attempt/3..."
            
            SESSION_RESPONSE=$(curl -s -X POST http://127.0.0.1:4723/session \
              -H "Content-Type: application/json" \
              -d '{
                "capabilities": {
                  "alwaysMatch": {
                    "platformName": "iOS",
                    "appium:automationName": "XCUITest",
                    "appium:deviceName": "'"${{ env.DEVICE_NAME }}"'",
                    "appium:udid": "'"$SIMULATOR_UDID"'",
                    "appium:platformVersion": "'"${{ env.PLATFORM_VERSION }}"'",
                    "appium:app": "'"$APP_PATH"'",
                    "appium:wdaLaunchTimeout": 600000,
                    "appium:wdaConnectionTimeout": 300000,
                    "appium:useNewWDA": false,
                    "appium:noReset": false
                  }
                }
              }' --max-time 600 2>&1) || true
            
            SESSION_ID=$(echo "$SESSION_RESPONSE" | grep -o '"sessionId":"[^"]*"' | cut -d'"' -f4 || true)
            
            if [ -n "$SESSION_ID" ]; then
              echo "âœ… WDA warm-up session created: $SESSION_ID"
              sleep 10
              curl -s -X DELETE "http://127.0.0.1:4723/session/$SESSION_ID" || true
              echo "âœ… Warm-up session closed"
              sleep 5
              echo "âœ… WDA warm-up complete"
              break
            else
              echo "âš ï¸ Attempt $attempt failed"
              [ $attempt -lt 3 ] && sleep 30
            fi
          done

      # ============================================================
      # START API CAPTURE (Before running tests)
      # ============================================================
      - name: Start API Traffic Capture
        if: github.event.inputs.capture_api != 'false'
        run: |
          echo "ğŸ“¡ Starting API traffic capture..."
          
          # Generate mitmproxy certificates
          timeout 5 mitmdump --set confdir=~/.mitmproxy 2>/dev/null || true
          
          # Install certificate in simulator (for HTTPS)
          if [ -f ~/.mitmproxy/mitmproxy-ca-cert.pem ]; then
            echo "Installing mitmproxy certificate in simulator..."
            xcrun simctl keychain "${{ env.SIMULATOR_UDID }}" add-root-cert ~/.mitmproxy/mitmproxy-ca-cert.pem 2>/dev/null || true
          fi
          
          # Start mitmproxy in background
          echo "Starting mitmproxy on port 8888..."
          mitmdump -w api_traffic.flow -p 8888 --set flow_detail=2 --quiet > mitmproxy.log 2>&1 &
          MITM_PID=$!
          echo "MITM_PID=$MITM_PID" >> $GITHUB_ENV
          
          sleep 3
          
          # Verify mitmproxy is running
          if ps -p $MITM_PID > /dev/null; then
            echo "âœ… mitmproxy started (PID: $MITM_PID)"
          else
            echo "âš ï¸ mitmproxy may not have started properly"
            cat mitmproxy.log 2>/dev/null || true
          fi
          
          # Configure macOS to use proxy (simulator uses system proxy)
          echo "Configuring system proxy..."
          networksetup -setwebproxy "Wi-Fi" 127.0.0.1 8888 2>/dev/null || true
          networksetup -setsecurewebproxy "Wi-Fi" 127.0.0.1 8888 2>/dev/null || true
          
          echo "âœ… API capture ready"

      - name: Run Smoke Tests
        id: smoke_tests
        continue-on-error: true
        env:
          SIMULATOR_UDID: ${{ env.SIMULATOR_UDID }}
          PLATFORM_VERSION: ${{ env.PLATFORM_VERSION }}
          DEVICE_NAME: ${{ env.DEVICE_NAME }}
          APP_PATH: ${{ github.workspace }}/apps/Z Platform-QA.app
          # Proxy settings for Java/Maven
          HTTP_PROXY: http://127.0.0.1:8888
          HTTPS_PROXY: http://127.0.0.1:8888
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘         ğŸ”¥ SMOKE TEST SUITE (17 tests)                     â•‘"
          echo "â•‘    Quick validation of critical paths (~15-20 min)         â•‘"
          echo "â•‘    ğŸ“¡ API Traffic Capture: ENABLED                         â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“‹ Tests included:"
          echo "   Authentication: TC01, TC04, TC07, TC16"
          echo "   Site Selection: TC_SS_001, TC_SS_003, TC_SS_007, TC_SS_014"
          echo "   Asset: ATS_ECR_01, ATS_ECR_02, ATS_ECR_14"
          echo "   Location: TC_NB_001, TC_NB_003, TC_NB_004"
          echo "   Connections: TC_CONN_001, TC_CONN_002, TC_CONN_004"
          echo ""
          mvn test -DsuiteXmlFile=src/test/resources/parallel/testng-smoke.xml \
            -DDEVICE_NAME="$DEVICE_NAME" \
            -DPLATFORM_VERSION="$PLATFORM_VERSION" \
            -DSIMULATOR_UDID="$SIMULATOR_UDID" \
            -DAPP_PATH="$APP_PATH"

      # ============================================================
      # STOP CAPTURE & GENERATE API REPORT
      # ============================================================
      - name: Generate API Traffic Report
        if: always() && github.event.inputs.capture_api != 'false'
        run: |
          echo "ğŸ“¡ Generating API traffic report..."
          
          # Stop proxy capture gracefully
          if [ -n "${{ env.MITM_PID }}" ]; then
            echo "Stopping mitmproxy (PID: ${{ env.MITM_PID }})..."
            kill ${{ env.MITM_PID }} 2>/dev/null || true
            sleep 3
          fi
          
          # Disable system proxy
          networksetup -setwebproxystate "Wi-Fi" off 2>/dev/null || true
          networksetup -setsecurewebproxystate "Wi-Fi" off 2>/dev/null || true
          
          # Check if we captured any traffic
          if [ -f "api_traffic.flow" ]; then
            FLOW_SIZE=$(ls -lh api_traffic.flow | awk '{print $5}')
            echo "âœ… API traffic captured: $FLOW_SIZE"
            
            # Install mitmproxy Python package for parsing
            pip install mitmproxy --quiet 2>/dev/null || true
            
            # Generate report
            python scripts/parse_api_traffic.py api_traffic.flow || true
            
            # Show summary in workflow log
            echo ""
            echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            echo "â•‘                 ğŸ“¡ API CAPTURE SUMMARY                     â•‘"
            echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            
            if [ -f "reports/api_logs/failed_apis.json" ]; then
              echo ""
              echo "âŒ Failed APIs detected:"
              cat reports/api_logs/failed_apis.json | head -100
            else
              echo "âœ… No failed APIs detected"
            fi
          else
            echo "âš ï¸ No API traffic was captured"
            echo "This may happen if:"
            echo "  - The app uses certificate pinning"
            echo "  - The app doesn't make network calls"
            echo "  - Proxy configuration failed"
          fi

      - name: Capture Smoke Test Status
        id: smoke_status
        if: always()
        run: |
          if [ "${{ steps.smoke_tests.outcome }}" == "success" ]; then
            echo "result=passed" >> $GITHUB_OUTPUT
            echo "âœ… SMOKE TESTS PASSED"
          else
            echo "result=failed" >> $GITHUB_OUTPUT
            echo "âŒ SMOKE TESTS FAILED"
          fi

      - name: Upload Smoke Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-report
          path: |
            target/surefire-reports/
            reports/
            screenshots/
            api_traffic.flow
            mitmproxy.log
          retention-days: 7

      - name: Smoke Test Summary
        if: always()
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘         ğŸ”¥ SMOKE TEST SUITE COMPLETE                       â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“Š Test Result: ${{ steps.smoke_status.outputs.result }}"
          echo ""
          echo "ğŸ“‹ Smoke Tests Coverage:"
          echo "   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
          echo "   â”‚ Module          â”‚ Tests â”‚ Purpose                        â”‚"
          echo "   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
          echo "   â”‚ Authentication  â”‚   4   â”‚ Welcome, Company Code, Login   â”‚"
          echo "   â”‚ Site Selection  â”‚   4   â”‚ UI, Site List, Search, Dashboardâ”‚"
          echo "   â”‚ Asset Managementâ”‚   3   â”‚ New Asset, Fields, Class       â”‚"
          echo "   â”‚ Location        â”‚   3   â”‚ Building UI, Save, Name        â”‚"
          echo "   â”‚ Connections     â”‚   3   â”‚ Tab, Header, List              â”‚"
          echo "   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
          echo ""
          echo "ğŸ“¡ API Capture: Enabled"
          echo "   - JSON Report: reports/api_logs/api_report.json"
          echo "   - HTML Report: reports/api_logs/api_report.html"
          echo "   - Failed APIs: reports/api_logs/failed_apis.json"
          echo ""
          echo "ğŸ”— Full Details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

  # ========================================
  # TRIGGER FULL SUITE (Optional)
  # ========================================
  trigger-full-suite:
    needs: smoke-tests
    if: |
      always() && 
      needs.smoke-tests.outputs.smoke_result == 'passed' && 
      github.event.inputs.run_full_suite_after == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 420
    
    steps:
      - name: Trigger Full Test Suite
        uses: actions/github-script@v7
        with:
          script: |
            console.log('ğŸš€ Smoke tests passed! Triggering full test suite...');
            
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ios-tests-parallel.yml',
              ref: context.ref,
              inputs: {
                job_selection: 'all'
              }
            });
            
            console.log('âœ… Full test suite triggered successfully');

      - name: Summary
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘    ğŸš€ FULL TEST SUITE TRIGGERED                            â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "âœ… Smoke tests passed - Full suite workflow dispatched"
          echo ""
          echo "ğŸ”— Check Actions tab for full suite progress"
